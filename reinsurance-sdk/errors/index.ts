/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number };
type MaybeErrorWithCode = ErrorWithCode | null | undefined;

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map();
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map();

/**
 * InsuranceExpiryTooClose: 'Can not create insurance that exists for less than 1 month'
 *
 * @category Errors
 * @category generated
 */
export class InsuranceExpiryTooCloseError extends Error {
  readonly code: number = 0x1770;
  readonly name: string = "InsuranceExpiryTooClose";
  constructor() {
    super("Can not create insurance that exists for less than 1 month");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, InsuranceExpiryTooCloseError);
    }
  }
}

createErrorFromCodeLookup.set(0x1770, () => new InsuranceExpiryTooCloseError());
createErrorFromNameLookup.set(
  "InsuranceExpiryTooClose",
  () => new InsuranceExpiryTooCloseError()
);

/**
 * InsuranceExpired: 'Can not send reinsurance proposal on expired insurance'
 *
 * @category Errors
 * @category generated
 */
export class InsuranceExpiredError extends Error {
  readonly code: number = 0x1771;
  readonly name: string = "InsuranceExpired";
  constructor() {
    super("Can not send reinsurance proposal on expired insurance");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, InsuranceExpiredError);
    }
  }
}

createErrorFromCodeLookup.set(0x1771, () => new InsuranceExpiredError());
createErrorFromNameLookup.set(
  "InsuranceExpired",
  () => new InsuranceExpiredError()
);

/**
 * InsuranceReinsuredAlready: 'Insurance already re-insured'
 *
 * @category Errors
 * @category generated
 */
export class InsuranceReinsuredAlreadyError extends Error {
  readonly code: number = 0x1772;
  readonly name: string = "InsuranceReinsuredAlready";
  constructor() {
    super("Insurance already re-insured");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, InsuranceReinsuredAlreadyError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1772,
  () => new InsuranceReinsuredAlreadyError()
);
createErrorFromNameLookup.set(
  "InsuranceReinsuredAlready",
  () => new InsuranceReinsuredAlreadyError()
);

/**
 * CanNotCallOffReinsurance: 'Reinsurance can not be called off unless premium more than week late'
 *
 * @category Errors
 * @category generated
 */
export class CanNotCallOffReinsuranceError extends Error {
  readonly code: number = 0x1773;
  readonly name: string = "CanNotCallOffReinsurance";
  constructor() {
    super(
      "Reinsurance can not be called off unless premium more than week late"
    );
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, CanNotCallOffReinsuranceError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1773,
  () => new CanNotCallOffReinsuranceError()
);
createErrorFromNameLookup.set(
  "CanNotCallOffReinsurance",
  () => new CanNotCallOffReinsuranceError()
);

/**
 * OutsideValidRange: 'Specified metadta outside accepted range'
 *
 * @category Errors
 * @category generated
 */
export class OutsideValidRangeError extends Error {
  readonly code: number = 0x1774;
  readonly name: string = "OutsideValidRange";
  constructor() {
    super("Specified metadta outside accepted range");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, OutsideValidRangeError);
    }
  }
}

createErrorFromCodeLookup.set(0x1774, () => new OutsideValidRangeError());
createErrorFromNameLookup.set(
  "OutsideValidRange",
  () => new OutsideValidRangeError()
);

/**
 * CanNotFullFillUnderCollateralizationDemands: 'LP can not fulfill under-collaterisation constraints'
 *
 * @category Errors
 * @category generated
 */
export class CanNotFullFillUnderCollateralizationDemandsError extends Error {
  readonly code: number = 0x1775;
  readonly name: string = "CanNotFullFillUnderCollateralizationDemands";
  constructor() {
    super("LP can not fulfill under-collaterisation constraints");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(
        this,
        CanNotFullFillUnderCollateralizationDemandsError
      );
    }
  }
}

createErrorFromCodeLookup.set(
  0x1775,
  () => new CanNotFullFillUnderCollateralizationDemandsError()
);
createErrorFromNameLookup.set(
  "CanNotFullFillUnderCollateralizationDemands",
  () => new CanNotFullFillUnderCollateralizationDemandsError()
);

/**
 * InsufficientVotingPower: 'Not enough voting power'
 *
 * @category Errors
 * @category generated
 */
export class InsufficientVotingPowerError extends Error {
  readonly code: number = 0x1776;
  readonly name: string = "InsufficientVotingPower";
  constructor() {
    super("Not enough voting power");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, InsufficientVotingPowerError);
    }
  }
}

createErrorFromCodeLookup.set(0x1776, () => new InsufficientVotingPowerError());
createErrorFromNameLookup.set(
  "InsufficientVotingPower",
  () => new InsufficientVotingPowerError()
);

/**
 * VotingOnStrategyClosed: 'Voting on strategy closed!'
 *
 * @category Errors
 * @category generated
 */
export class VotingOnStrategyClosedError extends Error {
  readonly code: number = 0x1777;
  readonly name: string = "VotingOnStrategyClosed";
  constructor() {
    super("Voting on strategy closed!");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, VotingOnStrategyClosedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1777, () => new VotingOnStrategyClosedError());
createErrorFromNameLookup.set(
  "VotingOnStrategyClosed",
  () => new VotingOnStrategyClosedError()
);

/**
 * NotEnoughVotes: 'Not enought votes to accept'
 *
 * @category Errors
 * @category generated
 */
export class NotEnoughVotesError extends Error {
  readonly code: number = 0x1778;
  readonly name: string = "NotEnoughVotes";
  constructor() {
    super("Not enought votes to accept");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, NotEnoughVotesError);
    }
  }
}

createErrorFromCodeLookup.set(0x1778, () => new NotEnoughVotesError());
createErrorFromNameLookup.set(
  "NotEnoughVotes",
  () => new NotEnoughVotesError()
);

/**
 * RefundDeclined: 'Can not refund before voting closes'
 *
 * @category Errors
 * @category generated
 */
export class RefundDeclinedError extends Error {
  readonly code: number = 0x1779;
  readonly name: string = "RefundDeclined";
  constructor() {
    super("Can not refund before voting closes");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, RefundDeclinedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1779, () => new RefundDeclinedError());
createErrorFromNameLookup.set(
  "RefundDeclined",
  () => new RefundDeclinedError()
);

/**
 * ClaimTooHigh: 'Can not raise claim greater than coverage amount'
 *
 * @category Errors
 * @category generated
 */
export class ClaimTooHighError extends Error {
  readonly code: number = 0x177a;
  readonly name: string = "ClaimTooHigh";
  constructor() {
    super("Can not raise claim greater than coverage amount");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, ClaimTooHighError);
    }
  }
}

createErrorFromCodeLookup.set(0x177a, () => new ClaimTooHighError());
createErrorFromNameLookup.set("ClaimTooHigh", () => new ClaimTooHighError());

/**
 * ClaimVotingClosed: 'Claim voting closes after 1 month'
 *
 * @category Errors
 * @category generated
 */
export class ClaimVotingClosedError extends Error {
  readonly code: number = 0x177b;
  readonly name: string = "ClaimVotingClosed";
  constructor() {
    super("Claim voting closes after 1 month");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, ClaimVotingClosedError);
    }
  }
}

createErrorFromCodeLookup.set(0x177b, () => new ClaimVotingClosedError());
createErrorFromNameLookup.set(
  "ClaimVotingClosed",
  () => new ClaimVotingClosedError()
);

/**
 * DecisionNotYetReleased: 'Can not release decision before voting closes'
 *
 * @category Errors
 * @category generated
 */
export class DecisionNotYetReleasedError extends Error {
  readonly code: number = 0x177c;
  readonly name: string = "DecisionNotYetReleased";
  constructor() {
    super("Can not release decision before voting closes");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, DecisionNotYetReleasedError);
    }
  }
}

createErrorFromCodeLookup.set(0x177c, () => new DecisionNotYetReleasedError());
createErrorFromNameLookup.set(
  "DecisionNotYetReleased",
  () => new DecisionNotYetReleasedError()
);

/**
 * ClaimVoteDidNotWin: 'Sadly your claim vote did not win!'
 *
 * @category Errors
 * @category generated
 */
export class ClaimVoteDidNotWinError extends Error {
  readonly code: number = 0x177d;
  readonly name: string = "ClaimVoteDidNotWin";
  constructor() {
    super("Sadly your claim vote did not win!");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, ClaimVoteDidNotWinError);
    }
  }
}

createErrorFromCodeLookup.set(0x177d, () => new ClaimVoteDidNotWinError());
createErrorFromNameLookup.set(
  "ClaimVoteDidNotWin",
  () => new ClaimVoteDidNotWinError()
);

/**
 * IncorrectRewardAmount: 'Incorrect Reward entered'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectRewardAmountError extends Error {
  readonly code: number = 0x177e;
  readonly name: string = "IncorrectRewardAmount";
  constructor() {
    super("Incorrect Reward entered");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, IncorrectRewardAmountError);
    }
  }
}

createErrorFromCodeLookup.set(0x177e, () => new IncorrectRewardAmountError());
createErrorFromNameLookup.set(
  "IncorrectRewardAmount",
  () => new IncorrectRewardAmountError()
);

/**
 * StrategyAllocationTooHigh: 'Strategy can not use fund higher than allocated'
 *
 * @category Errors
 * @category generated
 */
export class StrategyAllocationTooHighError extends Error {
  readonly code: number = 0x177f;
  readonly name: string = "StrategyAllocationTooHigh";
  constructor() {
    super("Strategy can not use fund higher than allocated");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, StrategyAllocationTooHighError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x177f,
  () => new StrategyAllocationTooHighError()
);
createErrorFromNameLookup.set(
  "StrategyAllocationTooHigh",
  () => new StrategyAllocationTooHighError()
);

/**
 * StreamMaturationNotYetReached: 'Stream date not yet reached'
 *
 * @category Errors
 * @category generated
 */
export class StreamMaturationNotYetReachedError extends Error {
  readonly code: number = 0x1780;
  readonly name: string = "StreamMaturationNotYetReached";
  constructor() {
    super("Stream date not yet reached");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, StreamMaturationNotYetReachedError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1780,
  () => new StreamMaturationNotYetReachedError()
);
createErrorFromNameLookup.set(
  "StreamMaturationNotYetReached",
  () => new StreamMaturationNotYetReachedError()
);

/**
 * StrategyStreamsEnded: 'All strategy streams already payed'
 *
 * @category Errors
 * @category generated
 */
export class StrategyStreamsEndedError extends Error {
  readonly code: number = 0x1781;
  readonly name: string = "StrategyStreamsEnded";
  constructor() {
    super("All strategy streams already payed");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, StrategyStreamsEndedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1781, () => new StrategyStreamsEndedError());
createErrorFromNameLookup.set(
  "StrategyStreamsEnded",
  () => new StrategyStreamsEndedError()
);

/**
 * StrategyBlocked: 'Strategy blocked due to security reasons'
 *
 * @category Errors
 * @category generated
 */
export class StrategyBlockedError extends Error {
  readonly code: number = 0x1782;
  readonly name: string = "StrategyBlocked";
  constructor() {
    super("Strategy blocked due to security reasons");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, StrategyBlockedError);
    }
  }
}

createErrorFromCodeLookup.set(0x1782, () => new StrategyBlockedError());
createErrorFromNameLookup.set(
  "StrategyBlocked",
  () => new StrategyBlockedError()
);

/**
 * VoteInsuranceProposalEnded: 'Voting on insurance proposal ended'
 *
 * @category Errors
 * @category generated
 */
export class VoteInsuranceProposalEndedError extends Error {
  readonly code: number = 0x1783;
  readonly name: string = "VoteInsuranceProposalEnded";
  constructor() {
    super("Voting on insurance proposal ended");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, VoteInsuranceProposalEndedError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1783,
  () => new VoteInsuranceProposalEndedError()
);
createErrorFromNameLookup.set(
  "VoteInsuranceProposalEnded",
  () => new VoteInsuranceProposalEndedError()
);

/**
 * VotingOnInsuranceProposalOngoing: 'Voting on insurance proposal has not ended yet'
 *
 * @category Errors
 * @category generated
 */
export class VotingOnInsuranceProposalOngoingError extends Error {
  readonly code: number = 0x1784;
  readonly name: string = "VotingOnInsuranceProposalOngoing";
  constructor() {
    super("Voting on insurance proposal has not ended yet");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, VotingOnInsuranceProposalOngoingError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1784,
  () => new VotingOnInsuranceProposalOngoingError()
);
createErrorFromNameLookup.set(
  "VotingOnInsuranceProposalOngoing",
  () => new VotingOnInsuranceProposalOngoingError()
);

/**
 * VoteOnInsuranceProposalUnSuccessful: 'Voting did not accept this insurance proposal'
 *
 * @category Errors
 * @category generated
 */
export class VoteOnInsuranceProposalUnSuccessfulError extends Error {
  readonly code: number = 0x1785;
  readonly name: string = "VoteOnInsuranceProposalUnSuccessful";
  constructor() {
    super("Voting did not accept this insurance proposal");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, VoteOnInsuranceProposalUnSuccessfulError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1785,
  () => new VoteOnInsuranceProposalUnSuccessfulError()
);
createErrorFromNameLookup.set(
  "VoteOnInsuranceProposalUnSuccessful",
  () => new VoteOnInsuranceProposalUnSuccessfulError()
);

/**
 * IncorrectMetadataAccount: 'Incorrect metadata account sent'
 *
 * @category Errors
 * @category generated
 */
export class IncorrectMetadataAccountError extends Error {
  readonly code: number = 0x1786;
  readonly name: string = "IncorrectMetadataAccount";
  constructor() {
    super("Incorrect metadata account sent");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, IncorrectMetadataAccountError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1786,
  () => new IncorrectMetadataAccountError()
);
createErrorFromNameLookup.set(
  "IncorrectMetadataAccount",
  () => new IncorrectMetadataAccountError()
);

/**
 * PoolLifecycleExceeded: 'Can not reinsure insurance beyond pool lifecycle'
 *
 * @category Errors
 * @category generated
 */
export class PoolLifecycleExceededError extends Error {
  readonly code: number = 0x1787;
  readonly name: string = "PoolLifecycleExceeded";
  constructor() {
    super("Can not reinsure insurance beyond pool lifecycle");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, PoolLifecycleExceededError);
    }
  }
}

createErrorFromCodeLookup.set(0x1787, () => new PoolLifecycleExceededError());
createErrorFromNameLookup.set(
  "PoolLifecycleExceeded",
  () => new PoolLifecycleExceededError()
);

/**
 * LifeCycleCanNotEndInPast: 'Can not have lifecycle end in past'
 *
 * @category Errors
 * @category generated
 */
export class LifeCycleCanNotEndInPastError extends Error {
  readonly code: number = 0x1788;
  readonly name: string = "LifeCycleCanNotEndInPast";
  constructor() {
    super("Can not have lifecycle end in past");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, LifeCycleCanNotEndInPastError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1788,
  () => new LifeCycleCanNotEndInPastError()
);
createErrorFromNameLookup.set(
  "LifeCycleCanNotEndInPast",
  () => new LifeCycleCanNotEndInPastError()
);

/**
 * CanNotRefundBeforePoolClose: 'Pool not closed yet'
 *
 * @category Errors
 * @category generated
 */
export class CanNotRefundBeforePoolCloseError extends Error {
  readonly code: number = 0x1789;
  readonly name: string = "CanNotRefundBeforePoolClose";
  constructor() {
    super("Pool not closed yet");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, CanNotRefundBeforePoolCloseError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x1789,
  () => new CanNotRefundBeforePoolCloseError()
);
createErrorFromNameLookup.set(
  "CanNotRefundBeforePoolClose",
  () => new CanNotRefundBeforePoolCloseError()
);

/**
 * SecurityRefundAmountEnteredIncorrect: 'Security refund calc incorrect'
 *
 * @category Errors
 * @category generated
 */
export class SecurityRefundAmountEnteredIncorrectError extends Error {
  readonly code: number = 0x178a;
  readonly name: string = "SecurityRefundAmountEnteredIncorrect";
  constructor() {
    super("Security refund calc incorrect");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, SecurityRefundAmountEnteredIncorrectError);
    }
  }
}

createErrorFromCodeLookup.set(
  0x178a,
  () => new SecurityRefundAmountEnteredIncorrectError()
);
createErrorFromNameLookup.set(
  "SecurityRefundAmountEnteredIncorrect",
  () => new SecurityRefundAmountEnteredIncorrectError()
);

/**
 * CanNotTransferToSecurityVaultBeforeLPClose: 'Can not transfer before lp close'
 *
 * @category Errors
 * @category generated
 */
export class CanNotTransferToSecurityVaultBeforeLPCloseError extends Error {
  readonly code: number = 0x178b;
  readonly name: string = "CanNotTransferToSecurityVaultBeforeLPClose";
  constructor() {
    super("Can not transfer before lp close");
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(
        this,
        CanNotTransferToSecurityVaultBeforeLPCloseError
      );
    }
  }
}

createErrorFromCodeLookup.set(
  0x178b,
  () => new CanNotTransferToSecurityVaultBeforeLPCloseError()
);
createErrorFromNameLookup.set(
  "CanNotTransferToSecurityVaultBeforeLPClose",
  () => new CanNotTransferToSecurityVaultBeforeLPCloseError()
);

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code);
  return createError != null ? createError() : null;
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name);
  return createError != null ? createError() : null;
}
